from pyparsing import nestedExpr

# flatten by one layer
flatten = lambda l: [item for sublist in l for item in sublist]

def nestexp(s):
    return nestedExpr().parseString( "(" + s + ")" ).asList()[0]

# convert back from list to string
def backtostring(lst):
    if lst == []:
        return ""
    head, tail = lst[0], lst[1:]
    if isinstance(head,str):
        if head == '||' or head == '&&':
            head = ' ' + head + ' '
        return head + backtostring(tail)
    else:
        return "(" + backtostring(head)  + ")" + backtostring(tail)


# subformulas outputs a list of all subformulas of formula phi
def subformulas(phi):
    spec = nestedExpr().parseString( "(" + phi + ")" ).asList()[0]
    accset = set()
    return sfhelper(spec,accset)

# uses a spec list as generated by nestedExpr() to recursively add subformulas to accset
def sfhelper(spec, accset):
    if spec == []: return accset
    head, tail = spec[0], spec[1:]
    whole = backtostring(spec)
    if isinstance(head, str):
        if head[:2] == "mu" or head[:2] == "nu": # recurse on the very next list, spec[1], and the rest of the tail
            fp_sf = backtostring([head, spec[1]])  # fixed-point subformula
            return sfhelper(spec[1], accset.union([fp_sf, whole])).union(sfhelper(spec[2:], set()))
        elif head[:2] == "<>":
            if len(head) > 2: 
                # if whole == head: 
                #     return sfhelper(tail, accset + [whole, head[2:]])
                # else:
                #     return sfhelper(tail, accset + [whole, head, head[2:]])
                return sfhelper(tail, accset.union([whole, head, head[2:]]))
            else: # only <> appears and is then followed by parentheses (another list/subformula)
                return sfhelper(tail, accset.union([whole]))
        elif head == "||" or head == "&&":
            return sfhelper(tail, accset)
        else: # case covering lone atomic props and vars
            # if whole == head: 
            #     return sfhelper(tail, accset.union([whole]))
            # else:
            #     return sfhelper(tail, accset.union([whole, head]))  
            return sfhelper(tail, accset.union([whole, head]))  
    else: # head is a list: recurse on head and tail
        if tail == []:
            return sfhelper(head,accset)
        else:
            return sfhelper(head,accset.union([whole])).union(sfhelper(tail,set()))






# TESTS:

# print backtostring([])
# print backtostring(['p'])
# print backtostring([['p || q']])
# print backtostring(['nuY.', ['muX.', ['p', '||', '<>X'], '&&', '<>Y']])
# print backtostring([['nuY.', ['muX.', [['p', '||', '<>X']], '&&', '<>Y']]])
# print backtostring([['p', '||', '<>X'], '&&', ['<>Y', '||', 'q']])

# ex = "(nuY.(muX.(((p || <>X)) && <>Y)))"
# print ex
# print nestexp(ex)
# print subformulas("nuY.(muX.((p || <>X) && <>Y))")
# print "\n"

# print subformulas("((<>Y && p) || (q && <>X))")

# ex = "!p"
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# ex = "p || q"
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# ex = "p && q"
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# ex = "p && (q || r)"
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# # ex = "(p || x) && q"  
# # print ex
# # print nestexp(ex)
# # print subformulas(ex)
# # print "\n"

# ex = "<>p"
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# ex = "<>(p && <>X)"
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# ex = "q && muX.(p || <>X)" 
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"

# ex = "(muX.(p || <>X)) || q"  
# print ex
# print nestexp(ex)
# # print subformulas(ex)
# print "\n"



